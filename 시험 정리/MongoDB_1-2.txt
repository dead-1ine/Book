# 4장. 인덱스 및 사용자 관리

- 인덱스 사용 이유 : 빠른 데이터 검색을 수행하기 위함
- 모든 인덱스 출력 : db.employees.getIndexes()
- 해당 인덱스 삭제 : db.employees.dropIndex()

    `db.employees.dropIndex({ename:1})`

- 인덱스 생성 : db.employees.createIndex()

    `db.employees.create({_id:1})`

    `db.employees.create({comm : 1})`

- 인덱스 재구성 : db.employees.reIndex()

- 인덱스의 특징
    1. 대소문자를 엄격히 구분
    2. 충분한 인덱스 EXTENT 크기를 설정해야 함

- 복합 인덱스 생성 : db.employees.createIndex(조건 2개 이상)

    `db.employees.createIndex(`

    `{empno : 1, deptno : -1})s`

- 쿼리의 수행내역을 설명 : .explain()

    `idb.employees.find({deptno : 10}).explain()`

- Hash인덱스 생성 : "hashed"

    `db.movie.createIndex({배급사 : "hashed"})`

    `db.movie.createIndex(`

    `{배급사 : "hashed"},`

    `{name : "배급사 해시 인덱스"})`

    hash는 자료구조를 사용하며, 검색효율이 좋음, 정렬은 하지 않음

- Unique 인덱스 : {unique : true}

    중복되지 않는 유일한 값들이 저장되는 필드

    `db.employees.createIndex(`

    `{empno : 1}, {unique : true})`

- Non-Unique 인덱스 : 따로 설정하지 않음

- 데이터 입력 : .insert()

    `db.employees.insert(`

    `{empno : 7933}, {ename : "ADAM"})`

- 부분 인덱스 : {partialFilterExpression : { }}

    일부 Document에 대해서만 인덱스 키를 저장하는 인덱스( 필드가 어떤 값일 때 인덱스를 생성하지 않을 지 설정할 수 있음 )

    `db.employees.createIndex(`

    `{제목 : 1},`

    `{partialFilterExpression : {제목 : "무제"}})`

- Sparse 인덱스 : {sparse : true}

    인덱스된 필드가 없는 도큐먼트는 무시

    `db.employees.createIndex(`

    `{comm : 1}, {sparse : true})`

- Background 인덱스 : {background : true}

    시스템 자원이 충분하지 않은 환경에서 효율적인 인덱스 활용 가능

    `db.employees.createIndex(`

    `{hiredate : 1}, {background : true})`

- Covered 인덱스

    index만의 검색만으로 조건을 만족하는 Document를 추출할 수 있음

    인덱스 스캔의 경우, 인덱스를 통해 조건을 만족하는 데이터를 검색한 후 컬렉션에 대한 추가 검색을 통해 데이터를 검색

- GeoSpatial 인덱스 : db.spatial.createIndex()

    좌표로 구성되는 2차원 구조로 하나의 Collection에 하나의 2D인덱스를 생성

    1. $near

        `db.spatial.find(`

        `{pos : [5,5]}}).limit(5)`

        .limit() : 최대 출력값을 지정

    2. $center : {$center : [[ ]]}

    3. $box : {$box : [[ ]]}

    해당 좌표에서 가장 가까운 BOX형 좌표를 검색할 떄 사용

    4. $polygon : {$polygon : [[ ]]}

    해당 좌표를 기준으로 가장 가까운 다면형 좌표를 검색할 때 사용

- GeoMetry 인덱스 : {$near : {geometry : { } }}

    geoJSON은 직선 또는 곡선의 교차에 의하여 이루어지는 추상적인 구조나 다각형과 같은 기하학 구조를 일컫는 말, 이러한 구조에 만들어지는 인덱스

- LineString Type : {$geoIntersects : {$geometry : {type : "LineString", } } }

---

# 사용자 생성과 관리

- OS인증 방식

    인스턴스를 시작할 때 접속을 허용할 클라이언트의 IP Address를 직접 지정

- DB인증 방식(보편적 사용)

    사용자가 데이터베이스에 접속하기 위해 사전에 사용자 ID와 암호를 데이터베이스 내에 생성한 후 접속할 때 인증

- 현재 생성되어 있는 사용자 계정 출력 : show users

- 사용자 만들기 : db.createUser()

    `db.createUser({user : "system",`

    `pwd : "manager",`

    `roles : [ "userAdminAnyDatabase",`

    `"dbAdminAnyDatabase",`

    `"readWriteAnyDatabase" ]})`

- 접속 가능 여부 확인 (1: 완료, 2: 거부) : db.auth()

    `db.auth({user:"system", pwd:"manager"})`

- ReadWrite권한 부여 : "readWrite"

    `db.createUser({user : "scott',`

    `pwd : "tiger", roles : [`

    `"dbAdmin", "readWrite" ]})`

- 사용자 암호 변경 : db.chageUserPassword()

    `db.changeUserPassword("scott", "1234")`

- MongoDB의 사용자 권한 룰 4가지 유형
    1. Database User Role(가장 기본)

        MongoDB 접속 및 해제할 수 있으며, Create, Update, Delete, Find작업을 수행할 수 있음

    2. DB Adminstration Role

        기본적으로 관리할 수 있는 권한이 부여됨

    3. Administrative

        DB Administration Role권한과 더불어 샤드(Shard) 시스템과 복제(Replication) 시스템을 구축 및 관리할 수 있는 권한이 부여됨

    4. Any Database Role

        사용자 룰에서 최상위 권한들이 부여됨

    - MongoDB 구동 시 반드시 --auth 파라미터를 이용하여 시작함

---

# 5장. DataModeling

- Data Modeling의 주요 특징
    1. 데이터와 프로세스 모두가 설계의 중심
    2. Rich Document Structure를 제공
        - 조인 문장을 사용하지 않기 때문에 빠른 성능의 쓰기와 읽기가 가능한데 이것을 RichDocument라고 함
    3. 조인하지 않음
    4. N : M 관계를 지원함
    5. 스키마 중심의 설계를 하지 않음

- Rich Document의 장단점
    - 장점
        1. 쿼리가 단순해지고 Join문을 실행할 필요가 없어 도큐먼트 단위의 데이터 저장에 효과적이며 빠른 성능이 보장
        2. 데이터 보안에 효과적
    - 단점
        1. Embedded 되는 도큐먼트의 크기는 최대 16MB범위에서 가능
        2. Embedded 되는 도큐먼트가 존재하지 않는 컬렉션에는 적합하지 않음

- 조건걸어 찾기 : .findOne()

    `db.ord_detail.findOne({ordid_id : o._id})`

- DBRef 함수 :[new DBRef()]

    `db.ord_detail.save(`

    `{ordid_id : [ new DBRef ("ord", x._id) ]})`

- Link 구조의 장단점
    - 장점
        1. 별도의 논리적 구조로 저장되기 때문에 도큐먼트 크기에 제한 받지 않음
        2. 비즈니스 룰 상 별도로 처리되는 데이터 구조에 적함
    - 단점
        1. 매번 논리적 구조 간에 Link해야 하기 때문에 Embedded 보다 성능이 떨어짐
        2. 컬렉션 개수가 증가하며 관리 비용이 듬

---

# 6장. 논리적 구조 & 물리적 구조

- Journal 설정 : --journal

    `mongod --dbpath / --journal`

- 최초 Extent 크기 설정 : {size: }

    `db.createCollection("s_emp", {capped:true, size : 8192})`

- 유효성 검사 : .validate()

    `db.s_emp.validate()`

- 데이터베이스 내에 저장된 파일을 OS상에 Restore : get

    `mongofiles get file.TXT`

- OS상의 파일을 DB내로 Upload : put

    `mongofiles put file.TXT`

- Upload된 파일 정보 확인 : list

    `mongofiles list`

- Upload되어 있는 파일 상태 정보 확인 : flies.find()

    `db.fs.files.find()`

---

# 7. ShardingSystem

- Node1을 위한 Shard Server 활성화(40001)

    `mongod --shardsvr --dbpath / --port 40001 --bind_ip localhost`

- Node2를 위한 Shard Server (40002)

    `mongod --shardsvr --dbpath / --port 40002 --bind_ip localhost`

- Node3를 위한 Shard Server (40003)

    `mongod --shardsvr --dbpaht / --port 40003 --bind_ip localhost`

- Node4를 위한 Config Server (50001)

    `mongod --configsvr --replSet rptconfig --dbpath /config1 --port 50001 --bind_ip localhost`

- Node5 Config2 Server (50002)

    `mongod --configsvr --replSet rptconfig --dbpath /config2 --port 50002 --bind_ip localhost`

- Node6 Config3 Server (50003)

    `mongod --configsvr --replSet rptconfig --dbpath /config3 --port 50003 --bind_ip localhost`

- 구축된 Config Server 중 하나의 서버에 접속

    `mongo --host localhost --port 50001`

- mongodb Cluster 만들기 : rs.initate()

    `rs.initate(`

    `{ _id : "rptconfig",`

    `configsvr : true,`

    `members : [`

    `{ _id : 0, host : "localhost : 50001},`

    `{ _id : 1, host : "localhost : 50002},`

    `{ _id : 2, host : "localhost : 50003}`

    `]})`

- Shard Cluster를 위한 MongoS 활성화

    `mongos --configdb rptconfig/localhost:50001, localhost:50002, localhost:50003 --port 20000`

- MongoS에 접속하여 각 샤드 서버를 등록

    `mongo --host localhost --port 20000`

- Shard 등록 : sh.addShard()

    `sh.addShard("localhost:40001")`

- Sharding 활성화 : sh.enableSharding()

    `sh.enableSharding("test")`

- Collection에 샤딩 활성화 : sh.shardCollection()

    `sh.shardCollection("test.employees", {empno : "hashed"})`

- 프로세스 설정 작업 완료 후 확인

    `db.getSiblingDB("admin").runCommand({listShards:1})`

- 분산 배치된 상태 확인 : sh.status()

    `sh.status()`

- Node4 Shard Server (40004)

    `mongod --shardsvr --dbpath /shard4 --port 40004 --bind_ip localhost`

- MongoS 프로세스로 접속

    `mongo --host localhost --port 20000`

- 샤드 서버 상태 확인 : db.getSiblingDB().runCommand()

    `db.getSiblingDB("admin").runCommand({listShards : 1})`

- ShardServer 추가 : sh.addShard()

    `sh.addShard("localhost:40004")`

---

# 8. ReplicaSet

- 우선순위 정하기 : priority.

    ```r
    > conf = {
    	_id : "rptmongo",
    	members : [
    		{_id : 0, host : "server_a:10001", priority.3},
    		{_id : 1, host : "server_b:10002", priority.1},
    		{_id : 2, host : "server_c:10003", priority.2},
    		{_id : 3, host : "server_e:10005", 
    		hidden:true,slaveDelay: 1800}
    ```

    priority.1,2,3 : 장애 발생 시 번호에 따라 Primary가 됨

    slaveDelay: 투표에 참요하지 않으며, 복제 데이터는 1,800초 이후부터 저장

- Secondary Only Member

    데이터를 저장하고 있지만 절대 프라이머리 서버가 될 수 없는 Only Secondary서버

    ```r
    > cfg = rs.conf()
    > cfg.members[0].priority = 0
    > cfg.members[1].priority = 0.5
    > rs.reconfig(cfg)
    ```

# 나머지는 pdf파일로.
