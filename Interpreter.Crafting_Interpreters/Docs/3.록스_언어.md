# 3. 록스 언어
---
## 3.1 안녕, 록스
## 3.2 하이레벨 언어
### 3.2.1 동적 타이핑
> 록스는 동적 타입 언어다. 변수에 어떤 타입의 값이라도 담을 수 있고, 하나의 변수는 임의의 시간에 타입이 다른 값을 보관할 수 있다. 잘못된 타입의 값에 연산을 수행하면 런타임 에러가 감지되어 리포트된다.
정적 타입을 선호하는 이유는 많지만 록스를 동적 타입 언어로 만든 이유는 실용적인 면이 더 크다. 정적 타입 체계는 배우고 구현할 양이 어마어마하다. 이걸 생략하면 언어가 더 간단해진다. 또한 타입 체크를 런타임으로 미루면 인터프리터 기동 후 더 빨리 코드를 실행할 수 있다.
### 3.2.2 자동 메모리 관리
하이레벨 언어의 존재 의의는 에러가 발생하기 쉬운 로우레벨의 고된 일을 덜어주는 것이다. 그런 점에서 스토리지를 손으로 일일이 할당/해제하는 것보다 더 지루한 것이 있을까? 
 
Reference Counting, Tracing Garbage Collection은 메모리 관리의 쌍벽을 이루는 기법이다. Reference counting은 구현하기 간단하여 Perl, PHP, Python도 처음에 이 방식을 택했지만, 시간이 지나면서 참조 횟수 계산의 한계가 드러났고 문제가 커졌다. 결국 이들 언어 모두 완전한 GC 기능을 추가하거나, 적어도 객체 사이클을 정리할 수 있을 만큼의 GC를 추가하게 되었다. 
 
## 3.3 데이터 타입
> 록스는 아래의 내장 데이터 타입(built-in data type)을 가지고 있다.
 
- Boolean: 불리언 값이 없는 로직은 없다. '참'과 '거짓'은 소프트웨어의 음과 양이다. 
```lox
true;
false;
```
 
- Number: 록스는 Double-precision floating point 한 종류의 숫자만 사용한다.
```lox
1234; // 정수
12.34; // 10진수
```

- String: 설명이 필요없다.
```lox
"I am a string";
""; // 빈 문자열 
"123"; // 숫자가 아닌 문자열
```
 
- Nil: '값 없음(no value)'를 나타낸다. 
 
"Null pointer error는 IT업계의 골칫덩이다. 그래서 언어에 null 값을 두지 말자는 의견이 분분한데, 정적 타입 언어라면 그렇게 하는 것이 더 이득이겠지만, 동적 타입 언어에서는 null을 제거하면 그냥 갖고 있는 것보다 훨씬 더 성가실 때가 많다."
 
## 3.4 표현식
> 내장 데이터 타입과 그 리터럴이 원자(atom)라면, 표현식(expression)은 분자(molecule)라고 볼 수 있다.
 
### 3.4.1 산술
### 3.4.2 비교와 동등성
### 3.4.3 논리 연산자
### 3.4.4 우선순위와 그룹핑
 
## 3.5 문장
> 표현식의 주 임무가 값(value)를 만드는 것이라면, 문장은 효과(effect)를 내는 역할을 한다.
- 예시: `print "Hello, world!";`

## 3.6 변수
> 변수는 var 문으로 선언한다. initializer를 생략하면 변수의 기본값은 nil이다.
 
## 3.7 제어 흐름
## 3.8 함수
return 문 없이 블록 끝까지 실행되면 암묵적으로 nil이 반환된다.
 
### 3.8.1 클로저
> 록스에서 함수는 first-class이므로 참조할 수 있고, 변수로 저장할 수 있고, 다른 함수에 전달할 수 있는 진짜 값이다.
```lox
fun addPair(a, b) {
  return a + b;
}

fun identity(a) {
  return a;
}

print identity(addPair)(1, 2); // 3 출력
```
 
함수 선언은 문장이라서 다른 함수 내부에 로컬 함수로 선언할 수도 있다.
```lox
fun outer() {
  fun local() {
    print "I'm local!";
  }

  local();
}
```
 
로컬 함수, 일급 함수, 블록 스코프가 한데 어우러지면 다음과 같이 재미난 상황이 연출된다. 
```lox
fun returnFunction() {
  var outside = "outside";

  fun inner() {
    print outside;
  }

  return inner;

var fn = returnFunction();
fn();
```
`inner()`는 주변 함수에 선언된 로컬 변수에 액세스한다. 위와 같이 동작할 수 있으려면, `inner()`는 자기가 사용하는 모든 주변 변수의 참조를 외부 함수가 리턴된 이후에도 계속 바라볼 수 있게 어딘가에 보관해야 한다. 이 일을 하는 함수를 **Closure**라고 한다. 
 
## 3.9 클래스
### 3.9.1 객체 지향 언어를 추구해야 할 이유가 있을까?

## 3.10 표준 라이브러리
> Core 또는 Standard 라이브러리는 인터프리터에 직접 구현된 기능의 집합으로, 사용자는 이 라이브러리를 바탕으로 코드를 작성한다.

## 연습문제
1. 몇 가지 록스 샘플 프로그램을 작성하고 실행하라. (록스 구현체는 내 리포지터리에 있는 걸 갖다 써도 된다.) 이 책에 없는 엣지 케이스도 만들어 테스트하라. 예상대로 작동되는가? 작동이 안된다면 그 이유는 뭘까?
2. 이 장에서 약식으로 개괄한 내용 중에는 많은 것들이 명시되어 있지 않다. 언어의 구문과 시맨틱에 대해 평소에 궁금했던 질문을 몇 가지 나열하라. 정답은 무엇이라고 생각하는가?
3. 록스는 아주 작은 언어이다. 록스를 실제 프로그램에서 사용한다면 어떤 기능이 빠져서 불편함을 느끼게 될까? (물론, 표준 라이브러리는 제외하고)
