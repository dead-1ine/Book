## Scanning(Lexing)
> 문자의 선형 스트림을 받아 '단어'에 더 가까운 연속적인 청크들로 묶는다. (프로그래밍에서는 토큰이라고 한다.)

## Parsing(구문분석)
> 플랫한 일련의 토큰을 받아 문법 특유의 중첩된 성질을 반영하는 트리 구조를 만든다. (이 트리는 소스 언어의 원시 구문 구조에 얼마나 가까운지에 따라 **파스 트리** 또는 **추상 구문**이라는 상이한 두 가지 이름으로 불린다.
Parser가 만든 트리 -> Syntax tree OR AST(Abstract Syntax Tree) OR Just Tree

## 정적 분석
대부분의 언어가 수행하는 첫 번째 분석 작업을 바인딩 또는 레졸루션(resolution)이라고 한다.
식별자(identifier)마다 이름이 정의된 곳을 찾아 이 둘을 연결 짓는 행위이다. 여기서 Scope(범위)가 중요한 역할을 한다.
- Binding, Resolution: 
- Scope: 어떤 이름으로 어떤 선언을 참조할 수 있는 소스 코드의 영역이다.

정적 타입 언어(statically typed language)는 이 단계에서 타입 체크를 실시한다. a와 b가 어디에 선언되어 있는지 알고 있으니 타입도 바로 알아낼 수 있다.

## 중간 표현(IR, Intermediate Representation)
> 프론트엔드는 프로그램이 작성된 소스 언어에 따라 달라지는 반면, 백엔드는 프로그램이 최종 실행될 타깃 아키텍처와 깊이 연관되어 있다.

그 중간에서 코드는 소스/타깃 포맷 어느 쪽에도 엮이지 않는 중간 표현 형태로 보관할 수 있다. -> 양쪽 언어 사이의 징검다리인 셈이다.

IR 덕분에 적은 노력으로도 여러 소스 언어 및 타깃 플랫폼을 지원할 수 있다. 
IR을 공유하면 작업이 획기적으로 줄어든다. 

## 최적화(Optimize)
사용자 프로그램이 의미하는 바를 파악하고 나면, 시맨틱은 같지만 더 효율적으로 구현한 다른 프로그램으로 자유로이 갈아 끼울 수 있다. 즉, 프로그램을 최적화할 수 있다.
(항상 꼭 같은 값으로 평가되는 표현식을 컴파일 타임에 미리 평가하여 표현식 코드를 그 결괏값으로 대체하는 기법이다.
 
```c
pennyArea = 3.14159 * (0.75 / 2) * (0.75 / 2);

# Change to this on COMPILE TIME!!
pennyArea = 0.441786093
```
 
최적화는 프로그래밍 언어 업계에서 막대한 비중을 차지한다. 
  
TODO: 무슨 얘긴지 이해해보자. 컴파일 타임 최적화를 하지 않고 런타임에 성능을 높인다는 것이 궁금하다.
하지만 놀랍게도 성공한 언어들은 컴파일 타임 최적화를 거의 하지 않는다. 실제로 Lua, CPython은 비교적 최적화가 덜 된 코드를 생성하여 주로 런타임에 성능을 높이는 데에 초점을 둔다. ->  

## 코드 생성
> 모든 최적화를 사용자 프로그램에 적용했다면, 이제 마지막으로 머신이 실제로 작동시킬 수 있는 형태로 바꿀 차례이다. 다시 말해, 코드 생성(Generating code, 줄여서 Code Gen)에서 '코드'란 일반적으로 CPU가 실행하는 원시 어셈블리와 비슷한 명령어(assembly-like instruction)를 나타내며, 인간이 읽을 수 있는 종류의 '소스 코드'가 아니다.

### 실제 CPU 명령어를 생성할 것인가, Virtual CPU 명령어를 생성할 것인가.
실제 기계어를 생성하면 OS가 칩에 직접 로드할 수 있는 실행 파일이 나온다. Native code는 매우 빠르지만 이 코드를 생성하는 작업량은 만만찮다. 
또한, 칩의 언어로 말을 한다는 것은 컴파일러가 특정 아키텍처에 매여 있다는 증거이다. (x86 기계어를 타깃으로 한 컴파일러가 ARM 장치에서 실행될 리 없다.)
 
이런 까닭에 유명한 해커들(Martin Richards, Niklaus Wirth)은 **컴파일러가 가상 머신 코드를 만들어내도록 개발했다.**
실제 칩 명령어가 아닌, 가상의 머신용 코드를 생성한 것이다. Wirth는 이식성이 있다는 뜻에서 P-Code(Portable)이라고 불렀는데, 명령어 하나당 1바이트 길이여서 지금은 보통 **Byte Code**라고 부른다.
 
이러한 합성 명령어(Synthetic instruction)는 언어의 시맨틱과 좀 더 가깝게 매핑되도록 디자인되어 어느 특정한 컴퓨터 아키텍처와 복잡하게 쌓인 역사적 특성에 별로 얽매이지 않는다. 언어의 로우 레벨 연산을 조밀하게 바이너리로 인코드한 것이라 볼 수 있다.
 
## 가상 머신
- 가상머신의 두 가지 옵션
    1. 바이트코드를 해당 머신의 네이티브 코드로 바꿔주는 미니 컴파일러를 각 타깃 아키텍처마다 만드는 것이다.
    2. 런타임에 가상의 아키텍처를 지원하는 가상의 칩을 에뮬레이트하는 프로그램, 즉 **가상 머신(VM, Virtual Machine)**을 만드는 것이다.
 
VM에서 바이트코드를 실행하는 것은 미리 네이티브 코드로 번역하여 실행한 것보다 당연히 느리다. 
하지만 그 대신 단순성과 이식성이라는 커다란 장점이 생긴다. (C로 VM을 구현하면 C컴파일러가 있는 모든 플랫폼에서 해당 언어를 실행할 수 있다.)
 
## 런타임 -> 내용이 불명확한 감이 있어 정리가 필요하다.

## 컴파일하는 것들의 종류
1. Single-path Compiler: 파싱, 분석, 코드 생성을 인터리브(interleave, 적절히 서로 끼워 맞춤)해서 구문 트리나 IR을 할당하지 않고 파서에서 출력 코드를 직접 생성하는 단순한 컴파일러
2. Tree-walk Interpreter: 
3. Transpiler(Source-to-Source OR Transocompiler)
4. JIT(Juist-In-Time Compilation)

## 컴파일러와 인터프리터
---
- Compiler: 소스 언어를 다른 언어(보통 더 로우레벨)로 번역하는 구현 기법이다. (바이트 코드나 기계어를 생성하는 작업이 바로 컴파일이다.) 다른 하이레벨 언어로 트랜스파일하는 것 역시 컴파일이다.
- Interpreter: 소스 코드를 받아 즉시 실행한다. 즉, 소스에서 바로 프로그램을 실행하는 것이다.

- CPython의 동작과정: Python Program을 CPython으로 실행하면, 코드가 파싱되고 내부 바이트코드 포맷으로 변환된 다음 VM 내부에서 실행된다. 사용자 입장에서는 소스를 주면 프로그램이 바로 실행되니 분명 인터프리터처럼 보인다. 하지만 CPython의 내막을 들여다보면 어떤 식으로든 컴파일이 진행되다는 사실을 알 수 있다. 따라서 CPython은 인터프리터이면서 동시에 컴파일러도 가지고 있다. (실제로 대부분의 스크립트 언어가 이런식으로 동작한다.)

## 연습문제
1. 여러분이 즐겨 쓰는 언어의 오픈 소스 구현체를 선택하여 소스 코드를 내려받고 여기저기 뜯어보라. 스캐너와 파서를 구현한 코드를 찾아보라. 그 코드는 손으로 작성되었는가? 아니면 렉스나 야크 같은 도구로 생성되었는가? (보통 파일 확장자가 .l 또는 .y면 후자에 해당한다.)
2. JIT 컴파일은 동적 타입 언어를 구현하는 가장 빠른 방법이지만 모든 언어가 JIT 컴파일을 활용하는 것은 아니다. **JIT 컴파일을 사용하지 않는 이유는 무엇일까?**
3. C로 컴파일되는 대부분의 Lisp 구현체에는 Lisp 코드를 바로 실행할 수 있는 인터프리터도 탑재되어 있다. 왜일까?
